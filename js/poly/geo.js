// koffee 1.6.0

/*
 0000000   00000000   0000000   
000        000       000   000  
000  0000  0000000   000   000  
000   000  000       000   000  
 0000000   00000000   0000000
 */
var Polyhedron, add, adjustXYZ, canonicalXYZ, canonicalize, dot, dual, edgeDist, mult, orthogonal, planarize, recenter, reciprocal, reciprocalC, reciprocalN, ref, rescale, tangentify, unit;

Polyhedron = require('./polyhedron');

dual = require('./topo').dual;

ref = require('./math'), add = ref.add, dot = ref.dot, mult = ref.mult, unit = ref.unit, orthogonal = ref.orthogonal, reciprocal = ref.reciprocal, edgeDist = ref.edgeDist;

tangentify = function(vertices, edges) {
    var STABILITY_FACTOR, c, e, j, len, newVs, t;
    STABILITY_FACTOR = 0.1;
    newVs = copyVecArray(vertices);
    for (j = 0, len = edges.length; j < len; j++) {
        e = edges[j];
        t = tangentPoint(newVs[e[0]], newVs[e[1]]);
        c = mult((1 - sqrt(dot(t, t))) * STABILITY_FACTOR / 2, t);
        newVs[e[0]] = add(newVs[e[0]], c);
        newVs[e[1]] = add(newVs[e[1]], c);
    }
    return newVs;
};

recenter = function(vertices, edges) {
    var edgecenters, j, len, polycenter, v;
    edgecenters = edges.map(function(arg) {
        var a, b;
        a = arg[0], b = arg[1];
        return tangentPoint(vertices[a], vertices[b]);
    });
    polycenter = [0, 0, 0];
    for (j = 0, len = edgecenters.length; j < len; j++) {
        v = edgecenters[j];
        polycenter = add(polycenter, v);
    }
    polycenter = mult(1 / edges.length, polycenter);
    return _.map(vertices, function(x) {
        return sub(x, polycenter);
    });
};

rescale = function(vertices) {
    var maxExtent, polycenter, s;
    polycenter = [0, 0, 0];
    maxExtent = _.max(_.map(vertices, function(x) {
        return mag(x);
    }));
    s = 1 / maxExtent;
    return _.map(vertices, function(x) {
        return [s * x[0], s * x[1], s * x[2]];
    });
};

planarize = function(vertices, faces) {
    var STABILITY_FACTOR, c, coords, f, j, k, len, len1, n, newVs, v;
    STABILITY_FACTOR = 0.1;
    newVs = copyVecArray(vertices);
    for (j = 0, len = faces.length; j < len; j++) {
        f = faces[j];
        coords = f.map(function(v) {
            return vertices[v];
        });
        n = normal(coords);
        c = calcCentroid(coords);
        if (dot(n, c) < 0) {
            n = mult(-1.0, n);
        }
        for (k = 0, len1 = f.length; k < len1; k++) {
            v = f[k];
            newVs[v] = add(newVs[v], mult(dot(mult(STABILITY_FACTOR, n), sub(c, vertices[v])), n));
        }
    }
    return newVs;
};

canonicalize = function(poly, Niter) {
    var edges, faces, i, j, maxChange, newVs, newpoly, oldVs, ref1;
    Polyhedron = require('./polyhedron').Polyhedron;
    if (Niter != null) {
        Niter;
    } else {
        Niter = 1;
    }
    klog("canonicalize " + poly.name);
    faces = poly.faces;
    edges = poly.edges();
    newVs = poly.vertices;
    maxChange = 1.0;
    for (i = j = 0, ref1 = Niter; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
        oldVs = copyVecArray(newVs);
        newVs = tangentify(newVs, edges);
        newVs = recenter(newVs, edges);
        newVs = planarize(newVs, faces);
        maxChange = _.max(_.map(_.zip(newVs, oldVs), function(arg) {
            var x, y;
            x = arg[0], y = arg[1];
            return mag(sub(x, y));
        }));
        if (maxChange < 1e-8) {
            break;
        }
    }
    klog("[canonicalization done, last |deltaV|=" + maxChange + "]");
    newpoly = new Polyhedron(poly.name, poly.faces, newVs);
    klog("canonicalize", newpoly);
    return newpoly;
};

reciprocalC = function(poly) {
    var c, centers, j, len;
    centers = poly.centers();
    for (j = 0, len = centers.length; j < len; j++) {
        c = centers[j];
        c = mult(1.0 / dot(c, c), c);
    }
    return centers;
};

reciprocalN = function(poly) {
    var ans, avgEdgeDist, centroid, f, j, k, len, len1, normalV, ref1, ref2, ref3, tmp, v1, v2, v3;
    ans = [];
    ref1 = poly.faces;
    for (j = 0, len = ref1.length; j < len; j++) {
        f = ref1[j];
        centroid = [0, 0, 0];
        normalV = [0, 0, 0];
        avgEdgeDist = 0.0;
        ref2 = f.slice(-2), v1 = ref2[0], v2 = ref2[1];
        for (k = 0, len1 = f.length; k < len1; k++) {
            v3 = f[k];
            centroid = add(centroid, poly.vertices[v3]);
            normalV = add(normalV, orthogonal(poly.vertices[v1], poly.vertices[v2], poly.vertices[v3]));
            avgEdgeDist += edgeDist(poly.vertices[v1], poly.vertices[v2]);
            ref3 = [v2, v3], v1 = ref3[0], v2 = ref3[1];
        }
        centroid = mult(1.0 / f.length, centroid);
        normalV = unit(normalV);
        avgEdgeDist = avgEdgeDist / f.length;
        tmp = reciprocal(mult(dot(centroid, normalV), normalV));
        ans.push(mult((1 + avgEdgeDist) / 2, tmp));
    }
    return ans;
};

canonicalXYZ = function(poly, nIterations) {
    var count, dpoly, j, ref1;
    if (nIterations != null) {
        nIterations;
    } else {
        nIterations = 1;
    }
    dpoly = dual(poly);
    for (count = j = 0, ref1 = nIterations; 0 <= ref1 ? j < ref1 : j > ref1; count = 0 <= ref1 ? ++j : --j) {
        dpoly.vertices = reciprocalN(poly);
        poly.vertices = reciprocalN(dpoly);
    }
    return new Polyhedron(poly.name, poly.faces, poly.vertices);
};

adjustXYZ = function(poly, nIterations) {
    var count, dpoly, j, ref1;
    if (nIterations != null) {
        nIterations;
    } else {
        nIterations = 1;
    }
    dpoly = dual(poly);
    for (count = j = 0, ref1 = nIterations; 0 <= ref1 ? j < ref1 : j > ref1; count = 0 <= ref1 ? ++j : --j) {
        dpoly.vertices = reciprocalC(poly);
        poly.vertices = reciprocalC(dpoly);
    }
    return new Polyhedron(poly.name, poly.faces, poly.vertices);
};

module.exports = {
    rescale: rescale,
    tangentify: tangentify,
    recenter: recenter,
    planarize: planarize,
    canonicalize: canonicalize,
    reciprocalN: reciprocalN,
    reciprocalC: reciprocalC,
    adjustXYZ: adjustXYZ,
    canonicalXYZ: canonicalXYZ
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VvLmpzIiwic291cmNlUm9vdCI6Ii4iLCJzb3VyY2VzIjpbIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7O0FBQUEsSUFBQTs7QUFnQ0EsVUFBQSxHQUFhLE9BQUEsQ0FBUSxjQUFSOztBQUNYLE9BQVMsT0FBQSxDQUFRLFFBQVI7O0FBQ1gsTUFBNkQsT0FBQSxDQUFRLFFBQVIsQ0FBN0QsRUFBRSxhQUFGLEVBQU8sYUFBUCxFQUFZLGVBQVosRUFBa0IsZUFBbEIsRUFBd0IsMkJBQXhCLEVBQW9DLDJCQUFwQyxFQUFnRDs7QUFHaEQsVUFBQSxHQUFhLFNBQUMsUUFBRCxFQUFXLEtBQVg7QUFFVCxRQUFBO0lBQUEsZ0JBQUEsR0FBbUI7SUFFbkIsS0FBQSxHQUFRLFlBQUEsQ0FBYSxRQUFiO0FBQ1IsU0FBQSx1Q0FBQTs7UUFFSSxDQUFBLEdBQUksWUFBQSxDQUFhLEtBQU0sQ0FBQSxDQUFFLENBQUEsQ0FBQSxDQUFGLENBQW5CLEVBQTBCLEtBQU0sQ0FBQSxDQUFFLENBQUEsQ0FBQSxDQUFGLENBQWhDO1FBRUosQ0FBQSxHQUFJLElBQUEsQ0FBSyxDQUFDLENBQUEsR0FBRSxJQUFBLENBQUssR0FBQSxDQUFJLENBQUosRUFBTSxDQUFOLENBQUwsQ0FBSCxDQUFBLEdBQW1CLGdCQUFuQixHQUFvQyxDQUF6QyxFQUE0QyxDQUE1QztRQUNKLEtBQU0sQ0FBQSxDQUFFLENBQUEsQ0FBQSxDQUFGLENBQU4sR0FBYyxHQUFBLENBQUksS0FBTSxDQUFBLENBQUUsQ0FBQSxDQUFBLENBQUYsQ0FBVixFQUFpQixDQUFqQjtRQUNkLEtBQU0sQ0FBQSxDQUFFLENBQUEsQ0FBQSxDQUFGLENBQU4sR0FBYyxHQUFBLENBQUksS0FBTSxDQUFBLENBQUUsQ0FBQSxDQUFBLENBQUYsQ0FBVixFQUFpQixDQUFqQjtBQU5sQjtXQU9BO0FBWlM7O0FBZWIsUUFBQSxHQUFXLFNBQUMsUUFBRCxFQUFXLEtBQVg7QUFFUCxRQUFBO0lBQUEsV0FBQSxHQUFjLEtBQUss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QVA7QUFFUixRQUFBOztRQUFBOztRQUFBLGNBQWU7O0lBQ2YsS0FBQSxHQUFRLElBQUEsQ0FBSyxJQUFMO0FBR1IsU0FBYSxpR0FBYjtRQUNJLEtBQUssQ0FBQyxRQUFOLEdBQWlCLFdBQUEsQ0FBWSxJQUFaO1FBQ2pCLElBQUksQ0FBQyxRQUFMLEdBQWlCLFdBQUEsQ0FBWSxLQUFaO0FBRnJCO1dBSUEsSUFBSSxVQUFKLENBQWUsSUFBSSxDQUFDLElBQXBCLEVBQTBCLElBQUksQ0FBQyxLQUEvQixFQUFzQyxJQUFJLENBQUMsUUFBM0M7QUFWUTs7QUFZWixNQUFNLENBQUMsT0FBUCxHQUNJO0lBQUEsT0FBQSxFQUFnQixPQUFoQjtJQUNBLFVBQUEsRUFBZ0IsVUFEaEI7SUFFQSxRQUFBLEVBQWdCLFFBRmhCO0lBR0EsU0FBQSxFQUFnQixTQUhoQjtJQUlBLFlBQUEsRUFBZ0IsWUFKaEI7SUFLQSxXQUFBLEVBQWdCLFdBTGhCO0lBTUEsV0FBQSxFQUFnQixXQU5oQjtJQU9BLFNBQUEsRUFBZ0IsU0FQaEI7SUFRQSxZQUFBLEVBQWdCLFlBUmhCIiwic291cmNlc0NvbnRlbnQiOlsiIyMjXG4gMDAwMDAwMCAgIDAwMDAwMDAwICAgMDAwMDAwMCAgIFxuMDAwICAgICAgICAwMDAgICAgICAgMDAwICAgMDAwICBcbjAwMCAgMDAwMCAgMDAwMDAwMCAgIDAwMCAgIDAwMCAgXG4wMDAgICAwMDAgIDAwMCAgICAgICAwMDAgICAwMDAgIFxuIDAwMDAwMDAgICAwMDAwMDAwMCAgIDAwMDAwMDAgICBcbiMjI1xuXG4jIFBvbHlow6lkcm9uaXNtZVxuIz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4jIEEgdG95IGZvciBjb25zdHJ1Y3RpbmcgYW5kIG1hbmlwdWxhdGluZyBwb2x5aGVkcmEgYW5kIG90aGVyIG1lc2hlc1xuIyAgICBcbiMgSW5jbHVkZXMgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNvbndheSBwb2x5aGVkcmFsIG9wZXJhdG9ycyBkZXJpdmVkXG4jIGZyb20gY29kZSBieSBtYXRoZW1hdGljaWFuIGFuZCBtYXRoZW1hdGljYWwgc2N1bHB0b3IgR2VvcmdlIFcuIEhhcnQgaHR0cDojd3d3Lmdlb3JnZWhhcnQuY29tL1xuI1xuIyBDb3B5cmlnaHQgMjAxOSwgQW5zZWxtIExldnNrYXlhXG4jIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuI1xuIz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiMgU2xvdyBDYW5vbmljYWxpemF0aW9uIEFsZ29yaXRobVxuI1xuIyBUaGlzIGFsZ29yaXRobSBoYXMgc29tZSBjb252ZXJnZW5jZSBwcm9ibGVtcywgd2hhdCByZWFsbHkgbmVlZHMgdG8gYmUgZG9uZSBpcyB0b1xuIyBzdW0gdGhlIHRocmVlIGZvcmNpbmcgZmFjdG9ycyB0b2dldGhlciBhcyBhIGNvbmhlcmVudCBmb3JjZSBhbmQgdG8gdXNlIGEgaGFsZi1kZWNlbnRcbiMgaW50ZWdyYXRvciB0byBtYWtlIHN1cmUgdGhhdCBpdCBjb252ZXJnZXMgd2VsbCBhcyBvcHBvc2VkIHRvIHRoZSBjdXJyZW50IGhhY2sgb2ZcbiMgYWQtaG9jIHN0YWJpbGl0eSBtdWx0aXBsaWVycy4gIElkZWFsbHkgb25lIHdvdWxkIGltcGxlbWVudCBhIGNvbmp1Z2F0ZSBncmFkaWVudFxuIyBkZXNjZW50IG9yIHNpbWlsYXIgcHJldHR5IHRoaW5nLlxuI1xuIyBPbmx5IHRyeSB0byB1c2UgdGhpcyBvbiBjb252ZXggcG9seWhlZHJhIHRoYXQgaGF2ZSBhIGNoYW5jZSBvZiBiZWluZyBjYW5vbmljYWxpemVkLFxuIyBvdGhlcndpc2UgaXQgd2lsbCBwcm9iYWJseSBibG93IHVwIHRoZSBnZW9tZXRyeS4gIEEgbXVjaCB0cmlja2llciAvIHNtYXJ0ZXIgc2VlZC1zeW1tZXRyeVxuIyBiYXNlZCBnZW9tZXRyaWNhbCByZWd1bGFyaXplciBzaG91bGQgYmUgdXNlZCBmb3IgZmFuY2llci93ZWlyZGVyIHBvbHloZWRyYS5cblxuUG9seWhlZHJvbiA9IHJlcXVpcmUgJy4vcG9seWhlZHJvbidcbnsgZHVhbCB9ID0gcmVxdWlyZSAnLi90b3BvJ1xueyBhZGQsIGRvdCwgbXVsdCwgdW5pdCwgb3J0aG9nb25hbCwgcmVjaXByb2NhbCwgZWRnZURpc3QgfSA9IHJlcXVpcmUgJy4vbWF0aCdcbiAgICBcbiMgYWRqdXN0cyB2ZXJ0aWNlcyBvbiBlZGdlcyBzdWNoIHRoYXQgZWFjaCBlZGdlIGlzIHRhbmdlbnQgdG8gYW4gb3JpZ2luIHNwaGVyZVxudGFuZ2VudGlmeSA9ICh2ZXJ0aWNlcywgZWRnZXMpIC0+XG4gICAgIyBoYWNrIHRvIGltcHJvdmUgY29udmVyZ2VuY2VcbiAgICBTVEFCSUxJVFlfRkFDVE9SID0gMC4xXG4gICAgIyBjb3B5IHZlcnRpY2VzXG4gICAgbmV3VnMgPSBjb3B5VmVjQXJyYXkgdmVydGljZXNcbiAgICBmb3IgZSBpbiBlZGdlc1xuICAgICAgICAjIHRoZSBwb2ludCBjbG9zZXN0IHRvIG9yaWdpblxuICAgICAgICB0ID0gdGFuZ2VudFBvaW50IG5ld1ZzW2VbMF1dLCBuZXdWc1tlWzFdXSBcbiAgICAgICAgIyBhZGp1c3RtZW50IGZyb20gc3BoZXJlXG4gICAgICAgIGMgPSBtdWx0ICgxLXNxcnQoZG90KHQsdCkpKSpTVEFCSUxJVFlfRkFDVE9SLzIsIHRcbiAgICAgICAgbmV3VnNbZVswXV0gPSBhZGQgbmV3VnNbZVswXV0sIGNcbiAgICAgICAgbmV3VnNbZVsxXV0gPSBhZGQgbmV3VnNbZVsxXV0sIGNcbiAgICBuZXdWc1xuXG4jIHJlY2VudGVycyBlbnRpcmUgcG9seWhlZHJvbiBzdWNoIHRoYXQgY2VudGVyIG9mIG1hc3MgaXMgYXQgb3JpZ2luXG5yZWNlbnRlciA9ICh2ZXJ0aWNlcywgZWRnZXMpIC0+XG4gICAgI2NlbnRlcnMgb2YgZWRnZXNcbiAgICBlZGdlY2VudGVycyA9IGVkZ2VzLm1hcCAoW2EsIGJdKSAtPiB0YW5nZW50UG9pbnQgdmVydGljZXNbYV0sIHZlcnRpY2VzW2JdXG4gICAgcG9seWNlbnRlciA9IFswIDAgMF1cbiAgICAjIHN1bSBjZW50ZXJzIHRvIGZpbmQgY2VudGVyIG9mIGdyYXZpdHlcbiAgICBmb3IgdiBpbiBlZGdlY2VudGVyc1xuICAgICAgICBwb2x5Y2VudGVyID0gYWRkIHBvbHljZW50ZXIsIHZcbiAgICBwb2x5Y2VudGVyID0gbXVsdCAxL2VkZ2VzLmxlbmd0aCwgcG9seWNlbnRlclxuICAgICMgc3VidHJhY3Qgb2ZmIGFueSBkZXZpYXRpb24gZnJvbSBjZW50ZXJcbiAgICBfLm1hcCB2ZXJ0aWNlcywgKHgpIC0+IHN1YiB4LCBwb2x5Y2VudGVyXG5cbiMgcmVzY2FsZXMgbWF4aW11bSByYWRpdXMgb2YgcG9seWhlZHJvbiB0byAxXG5yZXNjYWxlID0gKHZlcnRpY2VzKSAtPlxuICAgIHBvbHljZW50ZXIgPSBbMCAwIDBdXG4gICAgbWF4RXh0ZW50ID0gXy5tYXggXy5tYXAgdmVydGljZXMsICh4KSAtPiBtYWcgeFxuICAgIHMgPSAxIC8gbWF4RXh0ZW50XG4gICAgXy5tYXAgdmVydGljZXMsICh4KSAtPiBbcyp4WzBdLCBzKnhbMV0sIHMqeFsyXV1cblxuIyBhZGp1c3RzIHZlcnRpY2VzIGluIGVhY2ggZmFjZSB0byBpbXByb3ZlIGl0cyBwbGFuYXJpdHlcbnBsYW5hcml6ZSA9ICh2ZXJ0aWNlcywgZmFjZXMpIC0+XG4gICAgU1RBQklMSVRZX0ZBQ1RPUiA9IDAuMSAjIEhhY2sgdG8gaW1wcm92ZSBjb252ZXJnZW5jZVxuICAgIG5ld1ZzID0gY29weVZlY0FycmF5IHZlcnRpY2VzICMgY29weSB2ZXJ0aWNlc1xuICAgIGZvciBmIGluIGZhY2VzXG4gICAgICAgIGNvb3JkcyA9IGYubWFwICh2KSAtPiB2ZXJ0aWNlc1t2XVxuICAgICAgICBuID0gbm9ybWFsIGNvb3JkcyAjIGZpbmQgYXZnIG9mIG5vcm1hbHMgZm9yIGVhY2ggdmVydGV4IHRyaXBsZXRcbiAgICAgICAgYyA9IGNhbGNDZW50cm9pZCBjb29yZHMgIyBmaW5kIHBsYW5hciBjZW50cm9pZFxuICAgICAgICBpZiBkb3QobiwgYykgPCAwICMgY29ycmVjdCBzaWduIGlmIG5lZWRlZFxuICAgICAgICAgICAgbiA9IG11bHQgLTEuMCwgblxuICAgICAgICBmb3IgdiBpbiBmICMgcHJvamVjdCAodmVydGV4IC0gY2VudHJvaWQpIG9udG8gbm9ybWFsLCBzdWJ0cmFjdCBvZmYgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIG5ld1ZzW3ZdID0gYWRkIG5ld1ZzW3ZdLCBtdWx0IGRvdChtdWx0KFNUQUJJTElUWV9GQUNUT1IsIG4pLCBzdWIoYywgdmVydGljZXNbdl0pKSwgblxuICAgIG5ld1ZzXG5cbiMgY29tYmluZXMgYWJvdmUgdGhyZWUgY29uc3RyYWludCBhZGp1c3RtZW50cyBpbiBpdGVyYXRpdmUgY3ljbGVcbmNhbm9uaWNhbGl6ZSA9IChwb2x5LCBOaXRlcikgLT5cbiAgICB7UG9seWhlZHJvbn0gPSByZXF1aXJlICcuL3BvbHloZWRyb24nXG4gICAgTml0ZXIgPz0gMVxuICAgIGtsb2cgXCJjYW5vbmljYWxpemUgI3twb2x5Lm5hbWV9XCJcbiAgICBmYWNlcyA9IHBvbHkuZmFjZXNcbiAgICBlZGdlcyA9IHBvbHkuZWRnZXMoKVxuICAgIG5ld1ZzID0gcG9seS52ZXJ0aWNlc1xuICAgIG1heENoYW5nZSA9IDEuMCAjIGNvbnZlcmdlbmNlIHRyYWNrZXJcbiAgICBmb3IgaSBpbiBbMC4uTml0ZXJdXG4gICAgICAgIG9sZFZzID0gY29weVZlY0FycmF5IG5ld1ZzICNjb3B5IHZlcnRpY2VzXG4gICAgICAgIG5ld1ZzID0gdGFuZ2VudGlmeSBuZXdWcywgZWRnZXNcbiAgICAgICAgbmV3VnMgPSByZWNlbnRlciBuZXdWcywgZWRnZXNcbiAgICAgICAgbmV3VnMgPSBwbGFuYXJpemUgbmV3VnMsIGZhY2VzXG4gICAgICAgIG1heENoYW5nZSA9IF8ubWF4IF8ubWFwIF8uemlwKG5ld1ZzLCBvbGRWcyksIChbeCwgeV0pIC0+IG1hZyBzdWIgeCwgeVxuICAgICAgICBpZiBtYXhDaGFuZ2UgPCAxZS04XG4gICAgICAgICAgICBicmVha1xuICAgICMgb25lIHNob3VsZCBub3cgcmVzY2FsZSwgYnV0IG5vdCByZXNjYWxpbmcgaGVyZSBtYWtlcyBmb3IgdmVyeSBpbnRlcmVzdGluZyBudW1lcmljYWxcbiAgICAjIGluc3RhYmlsaXRpZXMgdGhhdCBtYWtlIGludGVyZXN0aW5nIG11dGFudHMgb24gbXVsdGlwbGUgYXBwbGljYXRpb25zLi4uXG4gICAgIyBtb3JlIGV4cGVyaWVuY2Ugd2lsbCB0ZWxsIHdoYXQgdG8gZG9cbiAgICAjbmV3VnMgPSByZXNjYWxlKG5ld1ZzKVxuICAgIGtsb2cgXCJbY2Fub25pY2FsaXphdGlvbiBkb25lLCBsYXN0IHxkZWx0YVZ8PSN7bWF4Q2hhbmdlfV1cIlxuICAgIG5ld3BvbHkgPSBuZXcgUG9seWhlZHJvbiBwb2x5Lm5hbWUsIHBvbHkuZmFjZXMsIG5ld1ZzXG4gICAga2xvZyBcImNhbm9uaWNhbGl6ZVwiIG5ld3BvbHlcbiAgICBuZXdwb2x5XG5cbiMgSGFja3kgQ2Fub25pY2FsaXphdGlvbiBBbGdvcml0aG1cbiMgVXNpbmcgY2VudGVyIG9mIGdyYXZpdHkgb2YgdmVydGljZXMgZm9yIGVhY2ggZmFjZSB0byBwbGFuYXJpemUgZmFjZXNcblxuIyBnZXQgdGhlIHNwaGVyaWNhbCByZWNpcHJvY2FscyBvZiBmYWNlIGNlbnRlcnNcbnJlY2lwcm9jYWxDID0gKHBvbHkpIC0+XG4gICAgY2VudGVycyA9IHBvbHkuY2VudGVycygpXG4gICAgZm9yIGMgaW4gY2VudGVyc1xuICAgICAgICBjID0gbXVsdCAxLjAvZG90KGMsYyksIGNcbiAgICBjZW50ZXJzXG5cbiMgbWFrZSBhcnJheSBvZiB2ZXJ0aWNlcyByZWNpcHJvY2FsIHRvIGdpdmVuIHBsYW5lc1xucmVjaXByb2NhbE4gPSAocG9seSkgLT5cbiAgICBhbnMgPSBbXVxuICAgIGZvciBmIGluIHBvbHkuZmFjZXMgI2ZvciBlYWNoIGZhY2VcbiAgICAgICAgY2VudHJvaWQgICAgPSBbMCAwIDBdICMgcnVubmluZyBzdW0gb2YgdmVydGV4IGNvb3Jkc1xuICAgICAgICBub3JtYWxWICAgICA9IFswIDAgMF0gIyBydW5uaW5nIHN1bSBvZiBub3JtYWwgdmVjdG9yc1xuICAgICAgICBhdmdFZGdlRGlzdCA9IDAuMCAjIHJ1bm5pbmcgc3VtIGZvciBhdmcgZWRnZSBkaXN0YW5jZVxuICAgIFxuICAgICAgICBbdjEsIHYyXSA9IGYuc2xpY2UgLTJcbiAgICAgICAgZm9yIHYzIGluIGZcbiAgICAgICAgICAgIGNlbnRyb2lkICAgICA9IGFkZCBjZW50cm9pZCwgcG9seS52ZXJ0aWNlc1t2M11cbiAgICAgICAgICAgIG5vcm1hbFYgICAgICA9IGFkZCBub3JtYWxWLCBvcnRob2dvbmFsIHBvbHkudmVydGljZXNbdjFdLCBwb2x5LnZlcnRpY2VzW3YyXSwgcG9seS52ZXJ0aWNlc1t2M11cbiAgICAgICAgICAgIGF2Z0VkZ2VEaXN0ICs9IGVkZ2VEaXN0IHBvbHkudmVydGljZXNbdjFdLCBwb2x5LnZlcnRpY2VzW3YyXVxuICAgICAgICAgICAgW3YxLCB2Ml0gPSBbdjIsIHYzXVxuICAgIFxuICAgICAgICBjZW50cm9pZCAgICA9IG11bHQgMS4wL2YubGVuZ3RoLCBjZW50cm9pZFxuICAgICAgICBub3JtYWxWICAgICA9IHVuaXQgbm9ybWFsVlxuICAgICAgICBhdmdFZGdlRGlzdCA9IGF2Z0VkZ2VEaXN0IC8gZi5sZW5ndGhcbiAgICAgICAgdG1wICAgPSByZWNpcHJvY2FsIG11bHQgZG90KGNlbnRyb2lkLCBub3JtYWxWKSwgbm9ybWFsViAjIGJhc2VkIG9uIGZhY2VcbiAgICAgICAgYW5zLnB1c2ggbXVsdCAoMSArIGF2Z0VkZ2VEaXN0KSAvIDIsIHRtcFxuICAgIGFuc1xuXG5jYW5vbmljYWxYWVogPSAocG9seSwgbkl0ZXJhdGlvbnMpIC0+XG4gICAgXG4gICAgbkl0ZXJhdGlvbnMgPz0gMVxuICAgIGRwb2x5ID0gZHVhbCBwb2x5XG4gICAgIyBrbG9nIFwiY2Fub25pY2FsWFlaICN7cG9seS5uYW1lfVwiXG4gIFxuICAgIGZvciBjb3VudCBpbiBbMC4uLm5JdGVyYXRpb25zXSAjIHJlY2lwcm9jYXRlIGZhY2Ugbm9ybWFsc1xuICAgICAgICBkcG9seS52ZXJ0aWNlcyA9IHJlY2lwcm9jYWxOIHBvbHlcbiAgICAgICAgcG9seS52ZXJ0aWNlcyAgPSByZWNpcHJvY2FsTiBkcG9seVxuICBcbiAgICBuZXcgUG9seWhlZHJvbiBwb2x5Lm5hbWUsIHBvbHkuZmFjZXMsIHBvbHkudmVydGljZXNcblxuYWRqdXN0WFlaID0gKHBvbHksIG5JdGVyYXRpb25zKSAtPiAjIHF1aWNrIHBsYW5hcml6YXRpb25cbiAgICBcbiAgICBuSXRlcmF0aW9ucyA/PSAxXG4gICAgZHBvbHkgPSBkdWFsIHBvbHkgIyB2J3Mgb2YgZHVhbCBhcmUgaW4gb3JkZXIgb2YgYXJnJ3MgZidzXG4gICAgIyBrbG9nIFwiYWRqdXN0WFlaICN7cG9seS5uYW1lfVwiXG4gIFxuICAgIGZvciBjb3VudCBpbiBbMC4uLm5JdGVyYXRpb25zXSAjIHJlY2lwcm9jYXRlIGZhY2UgY2VudGVyc1xuICAgICAgICBkcG9seS52ZXJ0aWNlcyA9IHJlY2lwcm9jYWxDIHBvbHlcbiAgICAgICAgcG9seS52ZXJ0aWNlcyAgPSByZWNpcHJvY2FsQyBkcG9seVxuICBcbiAgICBuZXcgUG9seWhlZHJvbiBwb2x5Lm5hbWUsIHBvbHkuZmFjZXMsIHBvbHkudmVydGljZXNcblxubW9kdWxlLmV4cG9ydHMgPSBcbiAgICByZXNjYWxlOiAgICAgICAgcmVzY2FsZVxuICAgIHRhbmdlbnRpZnk6ICAgICB0YW5nZW50aWZ5XG4gICAgcmVjZW50ZXI6ICAgICAgIHJlY2VudGVyXG4gICAgcGxhbmFyaXplOiAgICAgIHBsYW5hcml6ZVxuICAgIGNhbm9uaWNhbGl6ZTogICBjYW5vbmljYWxpemVcbiAgICByZWNpcHJvY2FsTjogICAgcmVjaXByb2NhbE5cbiAgICByZWNpcHJvY2FsQzogICAgcmVjaXByb2NhbENcbiAgICBhZGp1c3RYWVo6ICAgICAgYWRqdXN0WFlaXG4gICAgY2Fub25pY2FsWFlaOiAgIGNhbm9uaWNhbFhZWlxuICAgICJdfQ==
//# sourceURL=../../coffee/poly/geo.coffee