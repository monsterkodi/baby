// koffee 1.6.0

/*
 0000000   00000000   0000000   
000        000       000   000  
000  0000  0000000   000   000  
000   000  000       000   000  
 0000000   00000000   0000000
 */
var Polyhedron, _, add, calcCentroid, copyVecArray, dot, edgeDist, mag, mult, normal, orthogonal, planarize, recenter, reciprocal, reciprocalC, reciprocalN, ref, rescale, sqrt, sub, tangentPoint, tangentify, unit;

Polyhedron = require('./polyhedron');

_ = require('kxk')._;

ref = require('./math'), add = ref.add, sub = ref.sub, dot = ref.dot, mag = ref.mag, mult = ref.mult, unit = ref.unit, normal = ref.normal, orthogonal = ref.orthogonal, reciprocal = ref.reciprocal, edgeDist = ref.edgeDist, tangentPoint = ref.tangentPoint, calcCentroid = ref.calcCentroid, copyVecArray = ref.copyVecArray;

sqrt = Math.sqrt;

tangentify = function(vertices, edges) {
    var c, e, i, len, newVs, t;
    newVs = copyVecArray(vertices);
    for (i = 0, len = edges.length; i < len; i++) {
        e = edges[i];
        t = tangentPoint(newVs[e[0]], newVs[e[1]]);
        c = mult((1 - sqrt(dot(t, t))) * 0.05, t);
        newVs[e[0]] = add(newVs[e[0]], c);
        newVs[e[1]] = add(newVs[e[1]], c);
    }
    return newVs;
};

recenter = function(vertices, edges) {
    var edgecenters, i, len, polycenter, v;
    edgecenters = edges.map(function(arg) {
        var a, b;
        a = arg[0], b = arg[1];
        return tangentPoint(vertices[a], vertices[b]);
    });
    polycenter = [0, 0, 0];
    for (i = 0, len = edgecenters.length; i < len; i++) {
        v = edgecenters[i];
        polycenter = add(polycenter, v);
    }
    polycenter = mult(1 / edges.length, polycenter);
    return _.map(vertices, function(x) {
        return sub(x, polycenter);
    });
};

rescale = function(vertices) {
    var maxExtent, polycenter, s;
    polycenter = [0, 0, 0];
    maxExtent = _.max(_.map(vertices, function(x) {
        return mag(x);
    }));
    s = 1 / maxExtent;
    return _.map(vertices, function(x) {
        return [s * x[0], s * x[1], s * x[2]];
    });
};

planarize = function(vertices, faces) {
    var STABILITY_FACTOR, c, coords, f, i, j, len, len1, n, newVs, v;
    STABILITY_FACTOR = 0.1;
    newVs = copyVecArray(vertices);
    for (i = 0, len = faces.length; i < len; i++) {
        f = faces[i];
        coords = f.map(function(v) {
            return vertices[v];
        });
        n = normal(coords);
        c = calcCentroid(coords);
        if (dot(n, c) < 0) {
            n = mult(-1.0, n);
        }
        for (j = 0, len1 = f.length; j < len1; j++) {
            v = f[j];
            newVs[v] = add(newVs[v], mult(dot(mult(STABILITY_FACTOR, n), sub(c, vertices[v])), n));
        }
    }
    return newVs;
};

reciprocalC = function(poly) {
    var c, centers, i, len;
    centers = poly.centers();
    for (i = 0, len = centers.length; i < len; i++) {
        c = centers[i];
        c = mult(1.0 / dot(c, c), c);
    }
    return centers;
};

reciprocalN = function(poly) {
    var ans, avgEdgeDist, centroid, f, i, j, len, len1, normalV, ref1, ref2, ref3, tmp, v1, v2, v3;
    ans = [];
    ref1 = poly.faces;
    for (i = 0, len = ref1.length; i < len; i++) {
        f = ref1[i];
        centroid = [0, 0, 0];
        normalV = [0, 0, 0];
        avgEdgeDist = 0.0;
        ref2 = f.slice(-2), v1 = ref2[0], v2 = ref2[1];
        for (j = 0, len1 = f.length; j < len1; j++) {
            v3 = f[j];
            centroid = add(centroid, poly.vertices[v3]);
            normalV = add(normalV, orthogonal(poly.vertices[v1], poly.vertices[v2], poly.vertices[v3]));
            avgEdgeDist += edgeDist(poly.vertices[v1], poly.vertices[v2]);
            ref3 = [v2, v3], v1 = ref3[0], v2 = ref3[1];
        }
        centroid = mult(1.0 / f.length, centroid);
        normalV = unit(normalV);
        avgEdgeDist = avgEdgeDist / f.length;
        tmp = reciprocal(mult(dot(centroid, normalV), normalV));
        ans.push(mult((1 + avgEdgeDist) / 2, tmp));
    }
    return ans;
};

module.exports = {
    rescale: rescale,
    recenter: recenter,
    planarize: planarize,
    reciprocalN: reciprocalN,
    reciprocalC: reciprocalC,
    tangentify: tangentify
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VvLmpzIiwic291cmNlUm9vdCI6Ii4iLCJzb3VyY2VzIjpbIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7O0FBQUEsSUFBQTs7QUFzQkEsVUFBQSxHQUFhLE9BQUEsQ0FBUSxjQUFSOztBQUNYLElBQU0sT0FBQSxDQUFRLEtBQVI7O0FBQ1IsTUFBeUgsT0FBQSxDQUFRLFFBQVIsQ0FBekgsRUFBRSxhQUFGLEVBQU8sYUFBUCxFQUFZLGFBQVosRUFBaUIsYUFBakIsRUFBc0IsZUFBdEIsRUFBNEIsZUFBNUIsRUFBa0MsbUJBQWxDLEVBQTBDLDJCQUExQyxFQUFzRCwyQkFBdEQsRUFBa0UsdUJBQWxFLEVBQTRFLCtCQUE1RSxFQUEwRiwrQkFBMUYsRUFBd0c7O0FBQ3RHLE9BQVM7O0FBR1gsVUFBQSxHQUFhLFNBQUMsUUFBRCxFQUFXLEtBQVg7QUFFVCxRQUFBO0lBQUEsS0FBQSxHQUFRLFlBQUEsQ0FBYSxRQUFiO0FBQ1IsU0FBQSx1Q0FBQTs7UUFDSSxDQUFBLEdBQUksWUFBQSxDQUFhLEtBQU0sQ0FBQSxDQUFFLENBQUEsQ0FBQSxDQUFGLENBQW5CLEVBQTBCLEtBQU0sQ0FBQSxDQUFFLENBQUEsQ0FBQSxDQUFGLENBQWhDO1FBQ0osQ0FBQSxHQUFJLElBQUEsQ0FBSyxDQUFDLENBQUEsR0FBRSxJQUFBLENBQUssR0FBQSxDQUFJLENBQUosRUFBTSxDQUFOLENBQUwsQ0FBSCxDQUFBLEdBQW1CLElBQXhCLEVBQThCLENBQTlCO1FBQ0osS0FBTSxDQUFBLENBQUUsQ0FBQSxDQUFBLENBQUYsQ0FBTixHQUFjLEdBQUEsQ0FBSSxLQUFNLENBQUEsQ0FBRSxDQUFBLENBQUEsQ0FBRixDQUFWLEVBQWlCLENBQWpCO1FBQ2QsS0FBTSxDQUFBLENBQUUsQ0FBQSxDQUFBLENBQUYsQ0FBTixHQUFjLEdBQUEsQ0FBSSxLQUFNLENBQUEsQ0FBRSxDQUFBLENBQUEsQ0FBRixDQUFWLEVBQWlCLENBQWpCO0FBSmxCO1dBS0E7QUFSUzs7QUFXYixRQUFB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b250ZW50IjpbIiMjI1xuIDAwMDAwMDAgICAwMDAwMDAwMCAgIDAwMDAwMDAgICBcbjAwMCAgICAgICAgMDAwICAgICAgIDAwMCAgIDAwMCAgXG4wMDAgIDAwMDAgIDAwMDAwMDAgICAwMDAgICAwMDAgIFxuMDAwICAgMDAwICAwMDAgICAgICAgMDAwICAgMDAwICBcbiAwMDAwMDAwICAgMDAwMDAwMDAgICAwMDAwMDAwICAgXG4jIyNcbiNcbiMgUG9seWjDqWRyb25pc21lLCBDb3B5cmlnaHQgMjAxOSwgQW5zZWxtIExldnNrYXlhLCBNSVQgTGljZW5zZVxuI1xuIyBTbG93IENhbm9uaWNhbGl6YXRpb24gQWxnb3JpdGhtXG4jXG4jIFRoaXMgYWxnb3JpdGhtIGhhcyBzb21lIGNvbnZlcmdlbmNlIHByb2JsZW1zLCB3aGF0IHJlYWxseSBuZWVkcyB0byBiZSBkb25lIGlzIHRvXG4jIHN1bSB0aGUgdGhyZWUgZm9yY2luZyBmYWN0b3JzIHRvZ2V0aGVyIGFzIGEgY29uaGVyZW50IGZvcmNlIGFuZCB0byB1c2UgYSBoYWxmLWRlY2VudFxuIyBpbnRlZ3JhdG9yIHRvIG1ha2Ugc3VyZSB0aGF0IGl0IGNvbnZlcmdlcyB3ZWxsIGFzIG9wcG9zZWQgdG8gdGhlIGN1cnJlbnQgaGFjayBvZlxuIyBhZC1ob2Mgc3RhYmlsaXR5IG11bHRpcGxpZXJzLiAgSWRlYWxseSBvbmUgd291bGQgaW1wbGVtZW50IGEgY29uanVnYXRlIGdyYWRpZW50XG4jIGRlc2NlbnQgb3Igc2ltaWxhciBwcmV0dHkgdGhpbmcuXG4jXG4jIE9ubHkgdHJ5IHRvIHVzZSB0aGlzIG9uIGNvbnZleCBwb2x5aGVkcmEgdGhhdCBoYXZlIGEgY2hhbmNlIG9mIGJlaW5nIGNhbm9uaWNhbGl6ZWQsXG4jIG90aGVyd2lzZSBpdCB3aWxsIHByb2JhYmx5IGJsb3cgdXAgdGhlIGdlb21ldHJ5LiAgQSBtdWNoIHRyaWNraWVyIC8gc21hcnRlciBzZWVkLXN5bW1ldHJ5XG4jIGJhc2VkIGdlb21ldHJpY2FsIHJlZ3VsYXJpemVyIHNob3VsZCBiZSB1c2VkIGZvciBmYW5jaWVyL3dlaXJkZXIgcG9seWhlZHJhLlxuXG5Qb2x5aGVkcm9uID0gcmVxdWlyZSAnLi9wb2x5aGVkcm9uJ1xueyBfIH0gPSByZXF1aXJlICdreGsnXG57IGFkZCwgc3ViLCBkb3QsIG1hZywgbXVsdCwgdW5pdCwgbm9ybWFsLCBvcnRob2dvbmFsLCByZWNpcHJvY2FsLCBlZGdlRGlzdCwgdGFuZ2VudFBvaW50LCBjYWxjQ2VudHJvaWQsIGNvcHlWZWNBcnJheSB9ID0gcmVxdWlyZSAnLi9tYXRoJ1xueyBzcXJ0IH0gPSBNYXRoXG4gICAgXG4jIGFkanVzdHMgdmVydGljZXMgb24gZWRnZXMgc3VjaCB0aGF0IGVhY2ggZWRnZSBpcyB0YW5nZW50IHRvIGFuIG9yaWdpbiBzcGhlcmVcbnRhbmdlbnRpZnkgPSAodmVydGljZXMsIGVkZ2VzKSAtPlxuXG4gICAgbmV3VnMgPSBjb3B5VmVjQXJyYXkgdmVydGljZXNcbiAgICBmb3IgZSBpbiBlZGdlc1xuICAgICAgICB0ID0gdGFuZ2VudFBvaW50IG5ld1ZzW2VbMF1dLCBuZXdWc1tlWzFdXSBcbiAgICAgICAgYyA9IG11bHQgKDEtc3FydChkb3QodCx0KSkpKjAuMDUsIHRcbiAgICAgICAgbmV3VnNbZVswXV0gPSBhZGQgbmV3VnNbZVswXV0sIGNcbiAgICAgICAgbmV3VnNbZVsxXV0gPSBhZGQgbmV3VnNbZVsxXV0sIGNcbiAgICBuZXdWc1xuXG4jIHJlY2VudGVycyBlbnRpcmUgcG9seWhlZHJvbiBzdWNoIHRoYXQgY2VudGVyIG9mIG1hc3MgaXMgYXQgb3JpZ2luXG5yZWNlbnRlciA9ICh2ZXJ0aWNlcywgZWRnZXMpIC0+XG4gICAgI2NlbnRlcnMgb2YgZWRnZXNcbiAgICBlZGdlY2VudGVycyA9IGVkZ2VzLm1hcCAoW2EsIGJdKSAtPiB0YW5nZW50UG9pbnQgdmVydGljZXNbYV0sIHZlcnRpY2VzW2JdXG4gICAgcG9seWNlbnRlciA9IFswIDAgMF1cbiAgICAjIHN1bSBjZW50ZXJzIHRvIGZpbmQgY2VudGVyIG9mIGdyYXZpdHlcbiAgICBmb3IgdiBpbiBlZGdlY2VudGVyc1xuICAgICAgICBwb2x5Y2VudGVyID0gYWRkIHBvbHljZW50ZXIsIHZcbiAgICBwb2x5Y2VudGVyID0gbXVsdCAxL2VkZ2VzLmxlbmd0aCwgcG9seWNlbnRlclxuICAgICMgc3VidHJhY3Qgb2ZmIGFueSBkZXZpYXRpb24gZnJvbSBjZW50ZXJcbiAgICBfLm1hcCB2ZXJ0aWNlcywgKHgpIC0+IHN1YiB4LCBwb2x5Y2VudGVyXG5cbiMgcmVzY2FsZXMgbWF4aW11bSByYWRpdXMgb2YgcG9seWhlZHJvbiB0byAxXG5yZXNjYWxlID0gKHZlcnRpY2VzKSAtPlxuICAgIHBvbHljZW50ZXIgPSBbMCAwIDBdXG4gICAgbWF4RXh0ZW50ID0gXy5tYXggXy5tYXAgdmVydGljZXMsICh4KSAtPiBtYWcgeFxuICAgIHMgPSAxIC8gbWF4RXh0ZW50XG4gICAgXy5tYXAgdmVydGljZXMsICh4KSAtPiBbcyp4WzBdLCBzKnhbMV0sIHMqeFsyXV1cblxuIyBhZGp1c3RzIHZlcnRpY2VzIGluIGVhY2ggZmFjZSB0byBpbXByb3ZlIGl0cyBwbGFuYXJpdHlcbnBsYW5hcml6ZSA9ICh2ZXJ0aWNlcywgZmFjZXMpIC0+XG4gICAgU1RBQklMSVRZX0ZBQ1RPUiA9IDAuMSAjIEhhY2sgdG8gaW1wcm92ZSBjb252ZXJnZW5jZVxuICAgIG5ld1ZzID0gY29weVZlY0FycmF5IHZlcnRpY2VzICMgY29weSB2ZXJ0aWNlc1xuICAgIGZvciBmIGluIGZhY2VzXG4gICAgICAgIGNvb3JkcyA9IGYubWFwICh2KSAtPiB2ZXJ0aWNlc1t2XVxuICAgICAgICBuID0gbm9ybWFsIGNvb3JkcyAjIGZpbmQgYXZnIG9mIG5vcm1hbHMgZm9yIGVhY2ggdmVydGV4IHRyaXBsZXRcbiAgICAgICAgYyA9IGNhbGNDZW50cm9pZCBjb29yZHMgIyBmaW5kIHBsYW5hciBjZW50cm9pZFxuICAgICAgICBpZiBkb3QobiwgYykgPCAwICMgY29ycmVjdCBzaWduIGlmIG5lZWRlZFxuICAgICAgICAgICAgbiA9IG11bHQgLTEuMCwgblxuICAgICAgICBmb3IgdiBpbiBmICMgcHJvamVjdCAodmVydGV4IC0gY2VudHJvaWQpIG9udG8gbm9ybWFsLCBzdWJ0cmFjdCBvZmYgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIG5ld1ZzW3ZdID0gYWRkIG5ld1ZzW3ZdLCBtdWx0IGRvdChtdWx0KFNUQUJJTElUWV9GQUNUT1IsIG4pLCBzdWIoYywgdmVydGljZXNbdl0pKSwgblxuICAgIG5ld1ZzXG5cbiMgSGFja3kgQ2Fub25pY2FsaXphdGlvbiBBbGdvcml0aG1cbiMgVXNpbmcgY2VudGVyIG9mIGdyYXZpdHkgb2YgdmVydGljZXMgZm9yIGVhY2ggZmFjZSB0byBwbGFuYXJpemUgZmFjZXNcblxuIyBnZXQgdGhlIHNwaGVyaWNhbCByZWNpcHJvY2FscyBvZiBmYWNlIGNlbnRlcnNcbnJlY2lwcm9jYWxDID0gKHBvbHkpIC0+XG4gICAgY2VudGVycyA9IHBvbHkuY2VudGVycygpXG4gICAgZm9yIGMgaW4gY2VudGVyc1xuICAgICAgICBjID0gbXVsdCAxLjAvZG90KGMsYyksIGNcbiAgICBjZW50ZXJzXG5cbiMgbWFrZSBhcnJheSBvZiB2ZXJ0aWNlcyByZWNpcHJvY2FsIHRvIGdpdmVuIHBsYW5lc1xucmVjaXByb2NhbE4gPSAocG9seSkgLT5cbiAgICBhbnMgPSBbXVxuICAgIGZvciBmIGluIHBvbHkuZmFjZXMgI2ZvciBlYWNoIGZhY2VcbiAgICAgICAgY2VudHJvaWQgICAgPSBbMCAwIDBdICMgcnVubmluZyBzdW0gb2YgdmVydGV4IGNvb3Jkc1xuICAgICAgICBub3JtYWxWICAgICA9IFswIDAgMF0gIyBydW5uaW5nIHN1bSBvZiBub3JtYWwgdmVjdG9yc1xuICAgICAgICBhdmdFZGdlRGlzdCA9IDAuMCAjIHJ1bm5pbmcgc3VtIGZvciBhdmcgZWRnZSBkaXN0YW5jZVxuICAgIFxuICAgICAgICBbdjEsIHYyXSA9IGYuc2xpY2UgLTJcbiAgICAgICAgZm9yIHYzIGluIGZcbiAgICAgICAgICAgIGNlbnRyb2lkICAgICA9IGFkZCBjZW50cm9pZCwgcG9seS52ZXJ0aWNlc1t2M11cbiAgICAgICAgICAgIG5vcm1hbFYgICAgICA9IGFkZCBub3JtYWxWLCBvcnRob2dvbmFsIHBvbHkudmVydGljZXNbdjFdLCBwb2x5LnZlcnRpY2VzW3YyXSwgcG9seS52ZXJ0aWNlc1t2M11cbiAgICAgICAgICAgIGF2Z0VkZ2VEaXN0ICs9IGVkZ2VEaXN0IHBvbHkudmVydGljZXNbdjFdLCBwb2x5LnZlcnRpY2VzW3YyXVxuICAgICAgICAgICAgW3YxLCB2Ml0gPSBbdjIsIHYzXVxuICAgIFxuICAgICAgICBjZW50cm9pZCAgICA9IG11bHQgMS4wL2YubGVuZ3RoLCBjZW50cm9pZFxuICAgICAgICBub3JtYWxWICAgICA9IHVuaXQgbm9ybWFsVlxuICAgICAgICBhdmdFZGdlRGlzdCA9IGF2Z0VkZ2VEaXN0IC8gZi5sZW5ndGhcbiAgICAgICAgdG1wICAgPSByZWNpcHJvY2FsIG11bHQgZG90KGNlbnRyb2lkLCBub3JtYWxWKSwgbm9ybWFsViAjIGJhc2VkIG9uIGZhY2VcbiAgICAgICAgYW5zLnB1c2ggbXVsdCAoMSArIGF2Z0VkZ2VEaXN0KSAvIDIsIHRtcFxuICAgIGFuc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFxuICAgIHJlc2NhbGU6ICAgICAgICByZXNjYWxlXG4gICAgcmVjZW50ZXI6ICAgICAgIHJlY2VudGVyXG4gICAgcGxhbmFyaXplOiAgICAgIHBsYW5hcml6ZVxuICAgIHJlY2lwcm9jYWxOOiAgICByZWNpcHJvY2FsTlxuICAgIHJlY2lwcm9jYWxDOiAgICByZWNpcHJvY2FsQ1xuICAgIHRhbmdlbnRpZnk6ICAgICB0YW5nZW50aWZ5XG4gICAgIl19
//# sourceURL=../../coffee/poly/geo.coffee